'use strict';

const usb = require('usb');
const stream = require('stream');
const EventEmitter = require('eventemitter3');

/**
 * An object representing a USB device.
 *
 * @author Adam Yeats <ay@commonhq.com>
 * @extends EventEmitter
 */
class USBDevice extends EventEmitter {

  /**
   * Initialise a USB device.
   *
   * @param {String} vendor - The vendor ID as known to libusb.
   * @param {String} product - The product ID as known to libusb.
   */
  constructor (vendor, product) {
    super();

    // arrays for our USB endpoints
    this.in = [];
    this.out = [];

    this.current = {
      in: 0,
      out: 0
    };

    // ok, lets poll for USB devices
    try {
      this.device = usb.findByIds(vendor, product);
    }
    catch (e) {
      throw new Error('libusb error connecting to device: ', e.message);
    }

    // no device found?
    if (!this.device) {
      throw new Error(`Could not find device with VID ${vendor} and PID ${product}`);
    }

    usb.on('attach', (device)  => {
      if (this.device.idVendor === device.idVendor && this.device.idProduct === device.idProduct) {
        this.device = device;
      }
    });

    usb.on('detach', (device) => {
      if (this.device.idVendor === device.idVendor && this.device.idProduct === device.idProduct) {
        this.device = null;
      }
    });

    console.log('Found a device!');
  }

  /**
   * Send a raw command to the USB device. This is ideal for "one-shot" commands that are
   * somewhat fire-and-forget. Returns a promise as libusb is async. Note that it is not the
   * concern of this class to handle data conversion, so it's wise to handle that in a subclass.
   *
   * @param {String} cmd - The raw command to send to the USB device
   * @return {Promise} A promise
   */
  command (cmd) {
    return new Promise((resolve, reject) => {
      let buffer = new Buffer(cmd, 'utf8');
      let data = buffer.toString('ascii');

      if (!this.device) {
        let err = new Error('Device not found. Re-connect your device and try again.')
        return reject(err);
      }

      if (!this.out.length > 0) {
        return reject(new Error('There are no out endpoints to write to.'));
      }

      this.out[this.current.out].transfer(data, (err) => {
        // close the connection, we're done
        if (err) {
          return reject(err);
        }
        else {
          return resolve();
        }
      });
    });
  }

  /**
   * A streaming interface to the USB device. It is designed as an interface for
   * raw data only and generally calling the convenience methods would be preferred.
   * As this method just returns it's own stream, you can .pipe() more data to it.
   * Some methods call this in order to send chunks of data over USB at a time. For
   * some actions (image printing, for example) we may prefer a stream.
   *
   * @return {Stream} A stream to the USB printer
   */
  stream () {
    if (!this.device) {
      throw new Error('Device not found. Re-connect your device and try again.');
    }

    if (!this.out.length > 0) {
      throw new Error('There are no out endpoints to write to.');
    }

    return new stream.Writable({
      write: (chunk, encoding, next) => {
        this.out[this.current.out].transfer(chunk, (err) => {
          next(err);
        });
      }
    });
  }

  /**
   * Connect to the USB device. Required to communicate with the USB device with
   * the `#command()` method. It is recommended that you inherit from this class
   * and call this method from within your constructor.
   *
   * @return {object} The current interface assigned to this.interface
   */
  connect () {
    // this.device can be null if the usb detach event is fired, so do a check
    // here to see if it exists
    if (!this.device) {
      throw new Error('Device not found. Re-connect your device and try again.');
    }

    // open data connection to device
    this.device.open();

    // get interface
    this.interface = this.device.interfaces[0];

    // detatch the kernel driver if it exists. we want complete
    // ownership of the device
    if (this.interface.isKernelDriverActive()) {
      this.interface.detachKernelDriver();
    }

    this.interface.claim();

    // loop over available endpoints and add them to correct arrays
    this.interface.endpoints.forEach((endpoint, i) => {
      if (endpoint.direction === 'in') {
        this.in.push(endpoint);
      }
      else {
        this.out.push(endpoint);
      }
    })

    // emit an event to say we are ready
    super.emit('usb::ready', this.device);

    return this.interface;
  }

  /**
   * Disconnect and release the current USB device.
   *
   * @return {object} Lexical `this`, the current context
   */
  disconnect () {
    if (!this.device) {
      throw new Error('Device already disconnected, or not found.');
    }

    super.emit('usb::disconnect', this.device);

    return this.interface.release(() => {
      return this.device.close();
    });
  }
}

module.exports = USBDevice;